This file is a merged representation of the entire codebase, combined into a single document.
Generated by Repomix on: 2025-02-22T05:38:41.299Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
__tests__/
  check-changelog.test.ts
.github/
  workflows/
    test.yaml
  dependapot.yaml
src/
  check-changelog.ts
  index.ts
.eslintrc.json
.gitignore
action.yaml
jest.config.js
jest.setup.d.ts
jest.setup.js
jest.setup.ts
package.json
README.md
tsconfig.json

================================================================
Files
================================================================

================
File: __tests__/check-changelog.test.ts
================
import { checkChangelog } from '../src/check-changelog';
import { getOctokit } from '@actions/github';
import * as core from '@actions/core';
import * as fs from 'fs';

jest.mock('@actions/core');
jest.mock('fs');
jest.mock('@actions/exec', () => ({
  exec: jest.fn()
}));

jest.mock('@actions/github', () => ({
  getOctokit: jest.fn().mockReturnValue({
    rest: {
      issues: {
        addLabels: jest.fn().mockImplementation(() => Promise.resolve({ data: {} })),
        createComment: jest.fn().mockImplementation(() => Promise.resolve({ data: {} }))
      }
    }
  }),
  context: {
    repo: {
      owner: 'babarot',
      repo: 'test-repo'
    }
  }
}));

describe('checkChangelog', () => {
  const mockCore = core as jest.Mocked<typeof core>;
  const mockOctokit = getOctokit as jest.MockedFunction<typeof getOctokit>;

  beforeEach(() => {
    jest.clearAllMocks();

    mockCore.getInput.mockImplementation((name: string) => {
      switch (name) {
        case 'github-token':
          return 'dummy-token';
        case 'pull-request-number':
          return '1';
        case 'label-name':
          return 'empty-changelog';
        default:
          return '';
      }
    });
  });

  it('should detect empty changelog entries', async () => {
    // Mock exec
    const execMock = jest.requireMock('@actions/exec').exec;
    execMock.mockImplementation(async (_commandLine: string, _args?: string[], options?: { listeners?: { stdout?: (data: Buffer) => void } }) => {
      const mockDiff = `
+## [v1.4.2](https://github.com/user/repo/compare/v1.4.1...v1.4.2)
 ## [v1.4.1](https://github.com/user/repo/compare/v1.4.0...v1.4.1)
 ### Added
 - New feature
`;
      if (options?.listeners?.stdout) {
        options.listeners.stdout(Buffer.from(mockDiff));
      }
      return 0;
    });

    // Mock fs
    const mockChangelog = `
# Changelog

## [v1.4.2](https://github.com/user/repo/compare/v1.4.1...v1.4.2)

## [v1.4.1](https://github.com/user/repo/compare/v1.4.0...v1.4.1)
### Added
- New feature
`;
    (fs.readFileSync as jest.Mock).mockReturnValue(mockChangelog);

    await checkChangelog({
      baseSha: 'base-sha',
      headSha: 'head-sha'
    });

    expect(mockCore.setOutput).toHaveBeenCalledWith('has_empty_changelog', 'true');
    expect(mockCore.setOutput).toHaveBeenCalledWith('empty_headers', expect.stringContaining('v1.4.2'));
    expect(mockCore.warning).toHaveBeenCalledWith(expect.stringContaining('Empty changelog entries detected'));

    const octokitInstance = mockOctokit.mock.results[0].value;
    expect(octokitInstance.rest.issues.addLabels).toHaveBeenCalled();
    expect(octokitInstance.rest.issues.createComment).toHaveBeenCalled();
  });

  it('should handle non-empty changelog entries', async () => {
    const execMock = jest.requireMock('@actions/exec').exec;
    execMock.mockImplementation(async (_commandLine: string, _args?: string[], options?: { listeners?: { stdout?: (data: Buffer) => void } }) => {
      const mockDiff = `
+## [v1.4.2](https://github.com/user/repo/compare/v1.4.1...v1.4.2)
+### Added
+- New feature v1.4.2
 ## [v1.4.1](https://github.com/user/repo/compare/v1.4.0...v1.4.1)
`;
      if (options?.listeners?.stdout) {
        options.listeners.stdout(Buffer.from(mockDiff));
      }
      return 0;
    });

    const mockChangelog = `
# Changelog

## [v1.4.2](https://github.com/user/repo/compare/v1.4.1...v1.4.2)
### Added
- New feature v1.4.2

## [v1.4.1](https://github.com/user/repo/compare/v1.4.0...v1.4.1)
`;
    (fs.readFileSync as jest.Mock).mockReturnValue(mockChangelog);

    await checkChangelog({
      baseSha: 'base-sha',
      headSha: 'head-sha'
    });

    expect(mockCore.setOutput).toHaveBeenCalledWith('has_empty_changelog', 'false');
    expect(mockCore.setOutput).toHaveBeenCalledWith('empty_headers', '');
    expect(mockCore.warning).not.toHaveBeenCalled();

    const octokitInstance = mockOctokit.mock.results[0].value;
    expect(octokitInstance.rest.issues.addLabels).not.toHaveBeenCalled();
    expect(octokitInstance.rest.issues.createComment).not.toHaveBeenCalled();
  });

  it('should handle git diff errors properly', async () => {
    const execMock = jest.requireMock('@actions/exec').exec;
    execMock.mockRejectedValue(new Error('Git diff failed'));

    await checkChangelog({
      baseSha: 'base-sha',
      headSha: 'head-sha'
    });

    expect(mockCore.setFailed).toHaveBeenCalledWith('Action failed: Git diff failed');
  });

  it('should handle file read errors properly', async () => {
    const execMock = jest.requireMock('@actions/exec').exec;
    execMock.mockResolvedValue(0);

    (fs.readFileSync as jest.Mock).mockImplementation(() => {
      throw new Error('File read failed');
    });

    await checkChangelog({
      baseSha: 'base-sha',
      headSha: 'head-sha'
    });

    expect(mockCore.setFailed).toHaveBeenCalledWith('Action failed: File read failed');
  });

  it('should handle changelog entries when header is not found', async () => {
    const execMock = jest.requireMock('@actions/exec').exec;
    execMock.mockImplementation(async (_commandLine: string, _args?: string[], options?: { listeners?: { stdout?: (data: Buffer) => void } }) => {
      const mockDiff = `
+## [v1.4.2](https://github.com/user/repo/compare/v1.4.1...v1.4.2)
`;
      if (options?.listeners?.stdout) {
        options.listeners.stdout(Buffer.from(mockDiff));
      }
      return 0;
    });

    const mockChangelog = `
# Changelog

## [v1.4.1](https://github.com/user/repo/compare/v1.4.0...v1.4.1)
`;
    (fs.readFileSync as jest.Mock).mockReturnValue(mockChangelog);

    await checkChangelog({
      baseSha: 'base-sha',
      headSha: 'head-sha'
    });

    expect(mockCore.setOutput).toHaveBeenCalledWith('has_empty_changelog', 'false');
    expect(mockCore.setOutput).toHaveBeenCalledWith('empty_headers', '');
  });

  it('should handle changelog entries at the end of file', async () => {
    const execMock = jest.requireMock('@actions/exec').exec;
    execMock.mockImplementation(async (_commandLine: string, _args?: string[], options?: { listeners?: { stdout?: (data: Buffer) => void } }) => {
      const mockDiff = `
+## [v1.4.2](https://github.com/user/repo/compare/v1.4.1...v1.4.2)
`;
      if (options?.listeners?.stdout) {
        options.listeners.stdout(Buffer.from(mockDiff));
      }
      return 0;
    });

    const mockChangelog = `
# Changelog

## [v1.4.2](https://github.com/user/repo/compare/v1.4.1...v1.4.2)
`;
    (fs.readFileSync as jest.Mock).mockReturnValue(mockChangelog);

    await checkChangelog({
      baseSha: 'base-sha',
      headSha: 'head-sha'
    });

    expect(mockCore.setOutput).toHaveBeenCalledWith('has_empty_changelog', 'true');
    const octokitInstance = mockOctokit.mock.results[0].value;
    expect(octokitInstance.rest.issues.addLabels).toHaveBeenCalled();
    expect(octokitInstance.rest.issues.createComment).toHaveBeenCalled();
  });

  it('should handle unknown errors properly', async () => {
    const execMock = jest.requireMock('@actions/exec').exec;
    execMock.mockRejectedValue('Unknown error');

    await checkChangelog({
      baseSha: 'base-sha',
      headSha: 'head-sha'
    });

    expect(mockCore.setFailed).toHaveBeenCalledWith('Action failed with unknown error');
  });
});

================
File: .github/workflows/test.yaml
================
name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

permissions:
  contents: write
  pull-requests: write

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run lint
        run: npm run lint

      - name: Run tests
        run: npm test

      - name: Build
        run: npm run build

  release:
    needs: test
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build
        run: npm run build

      - name: Create Release Tag
        id: tag_version
        uses: mathieudutour/github-tag-action@v6.1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}

      - name: Create Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.tag_version.outputs.new_tag }}
          release_name: ${{ steps.tag_version.outputs.new_tag }}
          body: ${{ steps.tag_version.outputs.changelog }}
          draft: false
          prerelease: false

================
File: .github/dependapot.yaml
================
version: 2
updates:
  - package-ecosystem: "npm"
    directory: "/"
    schedule:
      interval: "weekly"
    versioning-strategy: increase
    groups:
      dependencies:
        patterns:
          - "@actions/*"
      dev-dependencies:
        patterns:
          - "@types/*"
          - "eslint*"
          - "jest*"
    labels:
      - "dependencies"
      - "automerge"

  - package-ecosystem: "github-actions"
    directory: "/"
    schedule:
      interval: "weekly"
    labels:
      - "dependencies"
      - "automerge"

================
File: src/check-changelog.ts
================
import { exec } from '@actions/exec';
import { getOctokit, context } from '@actions/github';
import * as core from '@actions/core';
import * as fs from 'fs';

interface CheckChangelogOptions {
  baseSha: string;
  headSha: string;
}

interface ChangelogEntry {
  header: string;
  content: string[];
  lineNumber: number;
}

export async function checkChangelog(options: CheckChangelogOptions): Promise<void> {
  core.info('Starting changelog check action...');

  const { baseSha, headSha } = options;
  core.info(`Checking changelog between ${baseSha} and ${headSha}`);

  core.info('Reading input parameters...');
  const token = core.getInput('github-token', { required: true });
  const prNumber = parseInt(core.getInput('pull-request-number', { required: true }), 10);
  const labelName = core.getInput('label-name', { required: false }) || 'empty-changelog';

  core.info(`Input parameters: PR #${prNumber}, Label: ${labelName}`);
  core.debug(`Using token: ${token.slice(0, 4)}...`);

  core.info('Initializing GitHub client...');
  const github = getOctokit(token);
  core.debug('GitHub client initialized');

  try {
    // Get diff with base branch
    core.info('Getting diff for CHANGELOG.md...');
    let diffOutput = '';
    await exec('git', ['diff', baseSha, headSha, '--', 'CHANGELOG.md'], {
      listeners: {
        stdout: (data: Buffer) => {
          diffOutput += data.toString();
        }
      }
    });
    core.debug(`Diff output length: ${diffOutput.length} characters`);

    // Read current CHANGELOG
    core.info('Reading current CHANGELOG.md...');
    const changelog = fs.readFileSync('CHANGELOG.md', 'utf8');
    const lines = changelog.split('\n');
    core.debug(`CHANGELOG.md has ${lines.length} lines`);

    // Find new headers in diff
    core.info('Analyzing changelog entries...');
    const newHeaders = diffOutput
      .split('\n')
      .filter(line => line.startsWith('+## ['))
      .map(line => line.substring(1)); // Remove the '+' prefix

    core.debug(`Found ${newHeaders.length} new version headers`);
    core.debug('New headers:');
    newHeaders.forEach(header => core.debug(`  ${header}`));

    const emptyEntries: ChangelogEntry[] = [];

    for (const header of newHeaders) {
      core.debug(`Checking content for header: ${header}`);
      const headerIndex = lines.findIndex(line => line === header);
      if (headerIndex === -1) {
        core.debug(`Header not found in current CHANGELOG: ${header}`);
        continue;
      }

      const nextHeaderIndex = lines
        .slice(headerIndex + 1)
        .findIndex(line => line.startsWith('## ['));

      const endIndex = nextHeaderIndex === -1
        ? lines.length
        : headerIndex + 1 + nextHeaderIndex;

      const content = lines
        .slice(headerIndex + 1, endIndex)
        .filter(line => line.trim() && !line.startsWith('## ['));

      core.debug(`Found ${content.length} content lines for header ${header}`);

      if (content.length === 0) {
        core.debug(`Empty content detected for header: ${header}`);
        emptyEntries.push({
          header: header.trim(),
          content: [],
          lineNumber: headerIndex + 1
        });
      }
    }

    if (emptyEntries.length > 0) {
      const headers = emptyEntries.map(entry => entry.header);
      core.setOutput('has_empty_changelog', 'true');
      core.setOutput('empty_headers', headers.join('\n'));

      core.info(`Found ${emptyEntries.length} empty changelog entries`);

      // Add label to PR
      core.info(`Adding label "${labelName}" to PR #${prNumber}...`);
      core.debug(`Repository: ${context.repo.owner}/${context.repo.repo}`);
      try {
        const labelResponse = await github.rest.issues.addLabels({
          owner: context.repo.owner,
          repo: context.repo.repo,
          issue_number: prNumber,
          labels: [labelName]
        });
        core.debug(`Label API Response: ${JSON.stringify(labelResponse)}`);
        core.info('Label added successfully');
      } catch (e) {
        core.error('Failed to add label');
        core.error(e instanceof Error ? e.message : 'Unknown error during label addition');
        throw e;
      }

      const warningMessage = [
        '🚨 Empty changelog entries detected:',
        ...headers.map(h => `- ${h} (No content provided)`)
      ].join('\n');

      // Add comment to PR
      core.info('Adding comment to PR...');
      try {
        const commentResponse = await github.rest.issues.createComment({
          owner: context.repo.owner,
          repo: context.repo.repo,
          issue_number: prNumber,
          body: warningMessage
        });
        core.debug(`Comment API Response: ${JSON.stringify(commentResponse)}`);
        core.info('Comment added successfully');
      } catch (e) {
        core.error('Failed to add comment');
        core.error(e instanceof Error ? e.message : 'Unknown error during comment addition');
        throw e;
      }

      core.warning(warningMessage);
    } else {
      core.info('No empty changelog entries found');
      core.setOutput('has_empty_changelog', 'false');
      core.setOutput('empty_headers', '');
    }
  } catch (error) {
    core.error('An error occurred during changelog check');
    if (error instanceof Error) {
      core.error(`Error details: ${error.message}`);
      core.error(error.stack || 'No stack trace available');
      core.setFailed(`Action failed: ${error.message}`);
    } else {
      core.error('Unknown error type received');
      core.setFailed('Action failed with unknown error');
    }
  }
}

================
File: src/index.ts
================
import * as core from '@actions/core';
import { context } from '@actions/github';
import { checkChangelog } from './check-changelog';

export async function run(): Promise<void> {
  try {
    core.info('Starting empty changelog check action...');

    const baseSha = context.payload.pull_request?.base.sha || '';
    const headSha = context.payload.pull_request?.head.sha || '';

    core.info(`Base SHA: ${baseSha}`);
    core.info(`Head SHA: ${headSha}`);

    if (!baseSha || !headSha) {
      throw new Error('Could not determine base or head SHA');
    }

    await checkChangelog({
      baseSha,
      headSha
    });

  } catch (error) {
    core.error('Action failed with an uncaught error');
    if (error instanceof Error) {
      core.setFailed(error.message);
    } else {
      core.setFailed('Unknown error occurred');
    }
  }
}

run();

================
File: .eslintrc.json
================
{
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended"
  ],
  "parser": "@typescript-eslint/parser",
  "plugins": ["@typescript-eslint"],
  "root": true
}

================
File: .gitignore
================
node_modules/
coverage/
*.log

================
File: action.yaml
================
name: 'Empty Changelog Check'
description: 'Check for empty changelog entries in pull requests'
author: 'babarot'

inputs:
  github-token:
    description: 'GitHub token for API operations'
    required: true
  label-name:
    description: 'Label to add when empty changelog is detected'
    required: false
    default: 'empty-changelog'
  pull-request-number:
    description: 'Pull request number to check'
    required: true

outputs:
  has_empty_changelog:
    description: 'Whether empty changelog entries were found'
  empty_headers:
    description: 'List of empty changelog headers'

runs:
  using: 'node20'
  main: 'dist/index.js'

branding:
  icon: 'alert-circle'
  color: 'yellow'

================
File: jest.config.js
================
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  testMatch: ['**/__tests__/**/*.test.ts'],
  collectCoverage: true,
  collectCoverageFrom: [
    'src/**/*.ts',
    '!src/types.ts'
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  },
  setupFiles: ['<rootDir>/jest.setup.ts']
};

================
File: jest.setup.d.ts
================
declare const fs: any;

================
File: jest.setup.js
================
"use strict";
const fs = require('fs');
jest.mock('fs', () => ({
    ...jest.requireActual('fs'),
    promises: {
        access: jest.fn(),
        appendFile: jest.fn(),
        writeFile: jest.fn(),
    },
    readFileSync: jest.fn(),
}));
process.env.GITHUB_WORKSPACE = '/github/workspace';
process.env.GITHUB_EVENT_PATH = '/github/workflow/event.json';

================
File: jest.setup.ts
================
const fs = require('fs');

jest.mock('fs', () => ({
  ...jest.requireActual('fs'),
  promises: {
    access: jest.fn(),
    appendFile: jest.fn(),
    writeFile: jest.fn(),
  },
  readFileSync: jest.fn(),
}));

process.env.GITHUB_WORKSPACE = '/github/workspace';
process.env.GITHUB_EVENT_PATH = '/github/workflow/event.json';

================
File: package.json
================
{
  "name": "empty-changelog-check",
  "version": "1.0.0",
  "description": "GitHub Action to check for empty changelog entries",
  "main": "dist/index.js",
  "scripts": {
    "build-old": "tsc",
    "test": "jest",
    "lint": "eslint src/**/*.ts",
    "prepare": "npm run build",
    "build": "ncc build src/check-changelog.ts -o dist"
  },
  "dependencies": {
    "@actions/core": "^1.10.1",
    "@actions/exec": "^1.1.1",
    "@actions/github": "^6.0.0"
  },
  "devDependencies": {
    "@types/jest": "^29.5.11",
    "@types/node": "^20.11.0",
    "@typescript-eslint/eslint-plugin": "^6.18.1",
    "@typescript-eslint/parser": "^6.18.1",
    "@vercel/ncc": "^0.38.3",
    "eslint": "^8.56.0",
    "jest": "^29.7.0",
    "ts-jest": "^29.1.1",
    "typescript": "^5.3.3"
  }
}

================
File: README.md
================
# Empty Changelog Check Action

A GitHub Action that checks for empty changelog entries in pull requests.

## Features

- Detects newly added changelog entries without content
- Adds a customizable label to PRs with empty changelog entries
- Provides detailed output about empty entries
- Supports customization through inputs

## Usage

```yaml
- uses: babarot/changelog-empty-check-action@v1
  with:
    github-token: ${{ secrets.GITHUB_TOKEN }}
    label-name: 'empty-changelog'  # optional
```

## Inputs

| Name | Description | Required | Default |
|------|-------------|----------|---------|
| `github-token` | GitHub token for API operations | Yes | `${{ github.token }}` |
| `label-name` | Label to add when empty changelog is detected | No | `empty-changelog` |

## Outputs

| Name | Description |
|------|-------------|
| `has_empty_changelog` | Whether empty changelog entries were found (`'true'` or `'false'`) |
| `empty_headers` | Newline-separated list of empty changelog headers |

## Example

```yaml
name: Check Empty Changelog

on:
  pull_request:
    paths:
      - 'CHANGELOG.md'

jobs:
  check-changelog:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: your-username/changelog-empty-check-action@v1
        id: check
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
```

## Development

1. Clone the repository
2. Install dependencies: `npm install`
3. Make changes in `src/`
4. Run tests: `npm test`
5. Build: `npm run build`

## License

MIT

## Contributing

Contributions are welcome! Please read our contributing guidelines and submit pull requests.

## Versioning

We use SemVer for versioning. For the versions available, see the tags on this repository.

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "commonjs",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "declaration": true
  },
  "include": ["src/**/*"],
  "exclude": ["__tests__/**/*", "jest.setup.ts", "dist"]
}



================================================================
End of Codebase
================================================================
